#!/usr/bin/env python
#
# Python program to help determine the AGC algorithm.
# 
# Jim Lawton 2012-10-03
# 
# This little utility is an attempt to try and systematically figure 
# out the algorithm for generating Superbank corrections, without 
# resorting to adding extra SBANK= directives.
#
# The input file is the listing generated by yaYUL when built with 
# YAYUL_TRACE. If ropediff has been run and generated an annotated 
# listing, then the annotated listing should be supplied, as core 
# errors can be corrected in the computation.

import sys
from optparse import OptionParser

def main():
    parser = OptionParser("usage: %prog listing_file")
    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.error("Listing file must be supplied!")
        sys.exit(1)

    lstfile = open(args[0], 'r')
    lines = lstfile.readlines()
   
    truth_table = {}
    truth_table["0-27"] = {}
    truth_table["30-33"] = {}
    truth_table["34-37"] = {}
    truth_table["40-43"] = {}

    records = []

    # ['FB=032,super=1,SB=0', 'bank=027,super=0', 'fix=0060', 'value=56060']
    for line in lines:
        record = {}
        record["input"] = {}
        record["address"] = {}
        record["output"] = {}
        if line.startswith('--- FixSuperbankBits:'):
            # PC=(FB=027,super=0) SB.super=0 addr=(bank=027,super=0,value=056003) fix=00060 value=056063
            fields = line.split()[2:]
            subfields = fields[0][4:-1].split(',')
            for subfield in subfields:
                [ name, value ] = subfield.split('=')
                record["input"][name] = value
            [ name, value ] = fields[1].split('=')
            record["input"][name] = value
            subfields = fields[2][6:-1].split(',')
            for subfield in subfields:
                [ name, value ] = subfield.split('=')
                record["address"][name] = value
            [ name, value ] = fields[3].split('=')
            record["output"][name] = value
            [ name, value ] = fields[4].split('=')
            record["output"][name] = value
            records.append(record)

        # >>> Core error 1 of 2 at 42,3632: expected 56100, got 56060
        if line.startswith('>>> Core error'):
            # Fix the last record.
            expected = line.split(':')[1].split()[1]
            if expected.endswith(','):
                expected = expected[:-1]
            actual = line.split(':')[1].split()[3]
            if len(records) == 0:
                print "Error: Core error before any traces, exiting!"
                sys.exit(1)
            record = records[-1]
            del records[-1]
            if record["output"]["value"] == actual:
                print "Correcting core error:", line.split(':')[1]
                record["output"]["value"] = expected
                record["output"]["fix"] = "%04o" % (int(expected, 8) & 0160)
                records.append(record)
            else:
                print "Error, core error mismatch, expected %s, got %s!" % (record["output"]["value"], actual)
            
    lstfile.close()

    print
    print " FBANK  Super  SB     Bank   Super  Fix"
    print " ------ ------ ------ ------ ------ ------"
 
    outlines = []
    for record in records:
        outlines.append(" %03s    %s      %s    %05s    %s      %04s" % (record["input"]["FB"], record["input"]["super"], record["input"]["SB.super"], record["address"]["bank"], record["address"]["super"], record["output"]["fix"]))
    
    outlines = list(set(outlines))
    outlines.sort()
    
    for line in outlines:
        print line

if __name__ == "__main__":
    main()
